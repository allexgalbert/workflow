Dependency Injection - для реализации слабосвязанной архитектуры.
Observer - для реализации публикации и подписки на поведение объекта, когда объект subject меняет состояние, прикрепленные объекты observers будут уведомлены. Используется чтобы сократить количество связанных напрямую объектов и использует слабую связь.
Facade - предназначен для разделения клиента и сложной подсистемы, путем внедрения одного интерфейса и уменьшения общей сложности.
Repository - посредних между контроллером и разными хранилищами, инкапсулирует в себе коллекцию объектов хранилища и сами операции выборки и сохранения.
Factory - фабрика для создания объектов разных типов но одинаковой структуры.
Strategy - выносить однообразные алгоритмы в отдельные классы и легко их заменять.
MVC - модель вью контроллер.
-------------------------------------------------

Dependency Injection

Инъекция зависимостей, это когда конструктор класса ждет зависимость в виде объекта нужного интерфейса или класса. При создании класса, в конструктор передаем объект, который реализует этот интерфейс или класс. Инъекция зависимостей это просто передача аргумента в конструктор или метод.

Инверсия зависимостей, это когда конструктор класса ждет зависимость в виде объекта только нужного интерфейса. А не конкретного класса.


Интерфейс
interface Interface {}

Классы
class Class1 implements Interface {}
class Class2 implements Interface {}

Класс
class Class {

  public function __construct(Interface $object) {
    $this->object = $object;
  }
  
  public function __construct(Class2 $object) {
    $this->object = $object;
  }
  
}

new Class(new Class1);
new Class(new Class2);
-------------------------------------------------

Observer

Объект observable
- издатель. создает события
- содержит список observers
- методы: add, remove, notify
- метод notify перебирает observers и вызывает у каждого метод handle

Объекты observers
- подписчики. разного типа
- наблюдают за событиями у observable
- метод handle

Использование в ларавел
- при сохранении, изменении, удалении модели
- вызываются классы из папки Observers
- там методы с такими же названиями
- обсерверы создаются командой php artisan make:observer name --model=name

В PHP использовать SplSubject, SplObserver, SplObjectStorage


class Observable {

  private $observers = [];
  
  public function add($observer) {$this->observers[] = $observer;}
  
  public function remove($observer) {unset($this->observers[$observer]);}
  
  public function notify($event) {
    foreach ($this->observers as $observer) {
      $observer->handle($this);
	  $observer->handle($event);
    }
  }
  
  public function notify($payload) {
    foreach ($this->observers as $observer) {
      $observer->handle($payload);
    }
  }
  
}

class Observer {
  public function handle($observable) {}
  public function handle($event) {}
  public function handle($payload) {}
}


$observable = new Observable;

$observer1 = new Observer;
$observer2 = new Observer;

$observable->add($observer1);
$observable->add($observer2);

$observable->notify();

$observable->remove($observer2);


class Event {}
$observable->notify(new Event);


$observable->notify($payload);
-------------------------------------------------

Facade

Сложная подсистема которую надо скрыть под фасадом
class Class1 {public function method1() {}}
class Class2 {public function method2() {}}

Фасад скрывает реализацию под собой, объединяя вызовы с разных мест, под одним методом
class Facade {

  protected $class1;
  protected $class2;

  public function _construct() {
    $this->class1 = new Class1;
	$this->class2 = new Class2;
  }
  
  public function start() {
    $this->class1->method1();
	$this->class2->method2();
  }
}

$facade =  new Facade;
$facade->start();

Под разными фасадами можно скрывать разные наборы вызываемых методов подсистемы
В ларавел папка Facades
В итоге все вызовы сложной подсистемы сводятся к вызову 1 метода у 1 объекта
-------------------------------------------------

Repository

обертка для модели. модель как источник данных
обертка содержит логику работы с данными

как книжный шкаф. только брать и класть
не может создавать и изменять

репозитарий это коллекция. это абстрактный слой между контроллером и разными хранилищами
в ларавел папка Repositories где репозитарии и интерфейсы

Методы. получить все записи и только записи юзера
interface Interface {
  public function method1()
  public function method2()
}

Реализации. юзеры лежат в базе или в файлах
class Class1 implements Interface {
  public function method1() {}
  public function method2() {}
}
class Class2 implements Interface {
  public function method1() {}
  public function method2() {}
}


class Class {

  private $repository;
  
  public function __construct(Interface $class) {
    $this->repository = $class;
  }

  public function method() {
    $this->repository->method1();
	$this->repository->method2();
  }
}

$class = new Class(new Class1);
$class = new Class(new Class2);


В ларавел вместо внедрения в конструкторе, можно привязать в провайдере
public function register() {
  $this->app->bind(Interface::class, Class1::class);
  $this->app->bind(Interface::class, Class2::class);
}
-------------------------------------------------

Factory

Кодеры и их действия
interface Developer {public function coding()}
class Java implements Developer {public function coding() {код}}
class Perl implements Developer {public function coding() {код}}

Фабрики для создания кодеров
interface Factory {public function create()}
class JavaFactory implements Factory {public function create() {return new Java;}}
class PerlFactory implements Factory {public function create() {return new Perl;}}


class Class {

  без фабричного метода. сами вызываем фабрику
  public function method() {
    $factory = new JavaFactory;
	$developer = $factory->create();
	$developer->coding();
  }
  
  фабричный метод. вызывает фабрику по типу
  public static function createMake($type) {
    if ($type == 'java') {
	  return new JavaFactory;
    }
	if ($type == 'perl') {
	  return new PerlFactory;
    }
  }
  
  с фабричным методом. передавая тип кодера которого нужно создать
  public function method() {
    $factory = self::createMake('java');
	$developer = $factory->create();
	$developer->coding();
  }
}
--------------------

class Factory {
  public function create($type) {
    if ($type == 'audi') {return new Audi;}
	if ($type == 'ford') {return new Ford;}
  }
}

$factory = new Factory;
$audi = factory->create('audi');
$ford = factory->create('ford');
--------------------

class Factory1 {public function create() {return new Audi;}}
class Factory2 {public function create() {return new Ford;}}

Абстрактная фабрика
class Main {
  public function make($type) {
	if ($type == 'audi') {return new Factory1;}
	if ($type == 'ford') {return new Factory2;}
  }
}

$factory = new Main;
$audi = factory->make('audi');
$ford = factory->make('ford');
-------------------------------------------------

Strategy

Выносить однообразные алгоритмы в отдельные классы и легко их заменять
Каждый алгоритм в своем классе. Семейство алгоритмов.
Выбирать алгоритм путем создания класса алгоритма.
Для легкой замены поведений. Стратегия заменяет поведения: алгоритм1, алгоритм2, алгоритм3,..


Активности разработчика: кодить, кушать

Интерфейс
interface Interface {
  выполнить активность
  public function do();
}

Классы активностей
class Coding implements Interface {public function do() {кодить}}
class Eating implements Interface {public function do() {кушать}}


Разработчик
class Developer {

  активность
  private $activity;
  
  установить активность
  public function set($activity) {
    $this->activity = $activity;
  }
  
  выполнить активность
  public function execute() {
    $this->activity->do();
  }
}

Рабочий код
$developer = new Developer;

$developer->set(new Coding);
$developer->execute();

$developer->set(new Eating);
$developer->execute();
-------------------------------------------------

MVC

Модель - бизнес логика, отдает данные.
 
Вью - слой презентации, оборачивает данные в нужный формат html, xml, csv, json. Вьюх может быть много разных в одном контроллере.

Контроллер - реагирует на события, принимает запросы от браузера или консоли, валидирует данные, делает запрос к модели, готовит данные для вью, отдает ответ.


class Model {
  public function getData() {return $data;}
}

class View {
  public function showData($data) {echo $data;}  
}

class Controller {
 
  private $model = new Model;
  private $view = new View;
  
  public function execute() {
    $data = $this->model->getData();
	$this->view->showData($data);
  }
}

$controller = new Controller;
$controller->execute();
-------------------------------------------------

Active Record

