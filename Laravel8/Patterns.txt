Observer - для реализации публикации и подписки на поведение объекта, когда объект subject меняет состояние, прикрепленные объекты observers будут уведомлены. Используется чтобы сократить количество связанных напрямую объектов и использует слабую связь.
Repository - посредних между контроллером и разными хранилищами, инкапсулирует в себе коллекцию объектов хранилища и сами операции выборки и сохранения.
Strategy - выносить однообразные алгоритмы в отдельные классы и легко их заменять.
MVC - модель вью контроллер.
-------------------------------------------------

Observer

Объект observable
- издатель. создает события
- содержит список observers
- методы: add, remove, notify
- метод notify перебирает observers и вызывает у каждого метод handle

Объекты observers
- подписчики. разного типа
- наблюдают за событиями у observable
- метод handle

Использование в ларавел
- при сохранении, изменении, удалении модели
- вызываются классы из папки Observers
- там методы с такими же названиями
- обсерверы создаются командой php artisan make:observer name --model=name

В PHP использовать SplSubject, SplObserver, SplObjectStorage


class Observable {

  private $observers = [];
  
  public function add($observer) {$this->observers[] = $observer;}
  
  public function remove($observer) {unset($this->observers[$observer]);}
  
  public function notify($event) {
    foreach ($this->observers as $observer) {
      $observer->handle($this);
	  $observer->handle($event);
    }
  }
  
  public function notify($payload) {
    foreach ($this->observers as $observer) {
      $observer->handle($payload);
    }
  }
  
}

class Observer {
  public function handle($observable) {}
  public function handle($event) {}
  public function handle($payload) {}
}


$observable = new Observable;

$observer1 = new Observer;
$observer2 = new Observer;

$observable->add($observer1);
$observable->add($observer2);

$observable->notify();

$observable->remove($observer2);


class Event {}
$observable->notify(new Event);


$observable->notify($payload);
-------------------------------------------------

Repository

обертка для модели. модель как источник данных
обертка содержит логику работы с данными

как книжный шкаф. только брать и класть
не может создавать и изменять

репозитарий это коллекция. это абстрактный слой между контроллером и разными хранилищами
в ларавел папка Repositories где репозитарии и интерфейсы

Методы. получить все записи и только записи юзера
interface Interface {
  public function method1()
  public function method2()
}

Реализации. юзеры лежат в базе или в файлах
class Class1 implements Interface {
  public function method1() {}
  public function method2() {}
}
class Class2 implements Interface {
  public function method1() {}
  public function method2() {}
}


class Class {

  private $repository;
  
  public function __construct(Interface $class) {
    $this->repository = $class;
  }

  public function method() {
    $this->repository->method1();
	$this->repository->method2();
  }
}

$class = new Class(new Class1);
$class = new Class(new Class2);


В ларавел вместо внедрения в конструкторе, можно привязать в провайдере
public function register() {
  $this->app->bind(Interface::class, Class1::class);
  $this->app->bind(Interface::class, Class2::class);
}
-------------------------------------------------

Strategy

Выносить однообразные алгоритмы в отдельные классы и легко их заменять
Каждый алгоритм в своем классе. Семейство алгоритмов.
Выбирать алгоритм путем создания класса алгоритма.
Для легкой замены поведений. Стратегия заменяет поведения: алгоритм1, алгоритм2, алгоритм3,..


Активности разработчика: кодить, кушать

Интерфейс
interface Interface {
  выполнить активность
  public function do();
}

Классы активностей
class Coding implements Interface {public function do() {кодить}}
class Eating implements Interface {public function do() {кушать}}


Разработчик
class Developer {

  активность
  private $activity;
  
  установить активность
  public function set($activity) {
    $this->activity = $activity;
  }
  
  выполнить активность
  public function execute() {
    $this->activity->do();
  }
}

Рабочий код
$developer = new Developer;

$developer->set(new Coding);
$developer->execute();

$developer->set(new Eating);
$developer->execute();
-------------------------------------------------

MVC

Модель - бизнес логика, отдает данные.
 
Вью - слой презентации, оборачивает данные в нужный формат html, xml, csv, json. Вьюх может быть много разных в одном контроллере.

Контроллер - реагирует на события, принимает запросы от браузера или консоли, валидирует данные, делает запрос к модели, готовит данные для вью, отдает ответ.


class Model {
  public function getData() {return $data;}
}

class View {
  public function showData($data) {echo $data;}  
}

class Controller {
 
  private $model = new Model;
  private $view = new View;
  
  public function execute() {
    $data = $this->model->getData();
	$this->view->showData($data);
  }
}

$controller = new Controller;
$controller->execute();
-------------------------------------------------

Active Record

