Dependency Injection - для реализации слабосвязанной архитектуры.
Adapter - привести неудобный интерфейс класса, в интерфейс совместимый с вашим кодом, предоставляя для этого прослойку с интерфейсом удобным для клиентов, а внутри себя используя оригинальный неудобный интерфейс.
Observer - для реализации публикации и подписки на поведение объекта, когда объект «subject» меняет состояние, прикрепленные объекты «observers» будут уведомлены. Используется чтобы сократить количество связанных напрямую объектов и использует слабую связь.
Facade - предназначен для разделения клиента и подсистемы путем внедрения одного интерфейса и уменьшения общей сложности.
Repository - посредних между контроллером и разными хранилищами, инкапсулирует набор объектов хранилища и сами операции выборки и сохранения.
-------------------------------------------------

Dependency Injection

Инъекция зависимостей, это когда конструктор класса ждет зависимость в виде объекта нужного интерфейса или класса. При создании класса, в конструктор передаем объект, который реализует этот интерфейс или класс. Инъекция зависимостей это просто передача аргумента в метод.

Инверсия зависимостей, это когда конструктор класса ждет зависимость в виде объекта только нужного интерфейса. А не конкретного класса.


Интерфейс
interface Interface {}

Классы
class Class1 implements Interface {}
class Class2 implements Interface {}

Класс
class Class {
  public function __construct(Interface $object) {
    $this->object = $object;
  }
  public function __construct(Class1 $object) {
    $this->object = $object;
  }
}

new Class(new Class1);
new Class(new Class2);
-------------------------------------------------

Adapter

2 библиотеки с разными интерфейсами и методами. Нужно заменить одну на другую, не меняя код по всему проекту.

Библиотека 1
interface Interface1 {public function method1() {}}
class Class1 implements Interface1 {public function method1() {}}

Библиотека 2
interface Interface2 {public function method2() {}}
class Class2 implements Interface2 {public function method2() {}}

Адаптер
class Adapter implements Interface1 {

  подключить библиотеку 2
  public function __construct() {$this->adapter = new Class2()}
  
  названия методов как в библиотеке 1, но внутри вызывают методы библиотеки 2
  public function method1() {$this->adapter->method2()}
}

Варианты
- объект класса Class2 создать в конструкторе
- класс Adapter наследовать от класса Class2


Работа с библиотекой 1
$var = app(Class1::class);
$var->method1();
	
Работа с адаптером. по факту с библиотекой 2
$var = app(Adapter::class);
$var->method1();
	
Можно улучшить так
$var = app(Interface1::class);
$var->method1();
	
В провайдере указать ларавелу, объект какого класса создавать, когда идет обращение к интерфейсу
$bindings = [Interface1::class => Adapter::class]
-------------------------------------------------

Observer

Объект observable
- издатель. создает события
- содержит список observers
- методы: add, remove, notify
- метод notify перебирает observers и вызывает у каждого метод handle

Объекты observers
- подписчики. разного типа
- наблюдают за событиями у observable
- метод handle

Использование в ларавел
- при сохранении, изменении, удалении модели
- вызываются классы из папки Observers
- там методы с такими же названиями
- обсерверы создаются командой php artisan make:observer name --model=name

В PHP использовать SplSubject, SplObserver, SplObjectStorage


class Observable {

  private $observers = [];
  
  public function add($observer) {$this->observers[] = $observer;}
  
  public function remove($observer) {unset($this->observers[$observer]);}
  
  public function notify($event) {
    foreach ($this->observers as $observer) {
      $observer->handle($this);
	  $observer->handle($event);
    }
  }
  
  public function notify($payload) {
    foreach ($this->observers as $observer) {
      $observer->handle($payload);
    }
  }
}

class Observer {
  public function handle($observable) {}
  public function handle($event) {}
  public function handle($payload) {}
}


$observable = new Observable();

$observer1 = new Observer();
$observer2 = new Observer();

$observable->add($observer1);
$observable->add($observer2);

$observable->notify();

$observable->remove($observer2);


class Event {}
$observable->notify(new Event());


$observable->notify($payload);
-------------------------------------------------

Facade

Сложная подсистема которую надо скрыть под фасадом
class Class1 {public function method1() {}}
class Class2 {public function method2() {}}

Фасад скрывает реализацию под собой, объединяя вызовы с разных мест, под одним методом
class Facade {

  protected $class1;
  protected $class2;

  public function _construct() {
    $this->class1 = new Class1;
	$this->class2 = new Class2;
  }
  
  public function start() {
    $this->class1->method1();
	$this->class2->method2();
  }
}

$facade =  new Facade;
$facade->start();

Под разными фасадами можно скрывать разные наборы вызываемых методов подсистемы
В ларавел папка Facades
В итоге все вызовы сложной подсистемы сводятся к вызову 1 метода у 1 объекта
-------------------------------------------------

Repository

обертка для модели
обертка содержит логику работы с данными
модель как источник данных

как книжный шкаф. только брать и класть
не может создавать и изменять

репозитарий это коллекция. это абстрактный слой между разными хранилищами и контроллером

в ларавел папка Repositories где репозитарии и интерфейсы


Методы. получить все записи и только записи юзера
interface Interface {
  public function method1() {}
  public function method2() {}
}

Реализации. юзеры лежат в базе или в файлах
class Class1 implements Interface {
  public function method1() {}
  public function method2() {}
}
class Class2 implements Interface {
  public function method1() {}
  public function method2() {}
}


Контроллер
class Class {

  private $repository;
  
  public function __construct(Interface $class1) {
    $this->repository = $class1;
  }

  public function method() {
    $this->repository->method1();
	$this->repository->method2();
  }
}

Вместо внедрения в конструкторе, можно привязать в сервис-провайдере:
public function register() {
  $this->app->bind(Interface::class, Class1::class);
}
-------------------------------------------------

